/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Flockr Social Proof API
 * API for sending product user actions and retrieving social proof
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@flockr.co
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://virtserver.swaggerhub.com/Flockr_AI/Flockr/1.0.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AltId
 */
export interface AltId {
    /**
     * 
     * @type {string}
     * @memberof AltId
     */
    altId: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event extends Request {
    /**
     * 
     * @type {EventEvent}
     * @memberof Event
     */
    event?: EventEvent;
}
/**
 * 
 * @export
 * @interface EventEvent
 */
export interface EventEvent {
    /**
     * The category of the event
     * @type {string}
     * @memberof EventEvent
     */
    category: string;
    /**
     * The name of the event
     * @type {string}
     * @memberof EventEvent
     */
    name: string;
    /**
     * 
     * @type {EventEventData}
     * @memberof EventEvent
     */
    data: EventEventData;
}
/**
 * 
 * @export
 * @interface EventEventData
 */
export interface EventEventData {
    /**
     * The id of the product (you can specify label, label & altId or altId)
     * @type {string}
     * @memberof EventEventData
     */
    label?: string;
    /**
     * An alternative ID for the product (you can specify label, label & altId or altId)
     * @type {string}
     * @memberof EventEventData
     */
    altId?: string;
    /**
     * The value for the event, e.g. the number of items added
     * @type {number}
     * @memberof EventEventData
     */
    value: number;
}
/**
 * 
 * @export
 * @interface Flockr
 */
export interface Flockr {
    /**
     * 
     * @type {FlockrResult}
     * @memberof Flockr
     */
    result?: FlockrResult;
    /**
     * 
     * @type {Array<SocialProof>}
     * @memberof Flockr
     */
    socialProof?: Array<SocialProof>;
    /**
     * 
     * @type {Array<SocialProof>}
     * @memberof Flockr
     */
    recommendations?: Array<SocialProof>;
}
/**
 * 
 * @export
 * @interface FlockrResult
 */
export interface FlockrResult {
    /**
     * 
     * @type {boolean}
     * @memberof FlockrResult
     */
    success?: boolean;
}
/**
 * 
 * @export
 * @interface List
 */
export interface List extends Request {
    /**
     * The category of the products - should not be an empty string
     * @type {string}
     * @memberof List
     */
    category: string;
    /**
     * An array of product IDs, also accepts an array of altIds, e.g. [{altId:\"abcdefg\"}]
     * @type {Array<string>}
     * @memberof List
     */
    products: Array<string>;
    /**
     * Optional list of product IDs to fetch proof values for (can be requested on a dedicated call instead if required)
     * @type {Array<string>}
     * @memberof List
     */
    recommendations?: Array<string>;
    /**
     * Anoptional map of productIds to image URL, if supplied Flockr will return an image URL for the social proof alon with the social proof values
     * @type {{ [key: string]: string; }}
     * @memberof List
     */
    images?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ListOnly
 */
export interface ListOnly extends Request {
    /**
     * Should be set to \"recommendations\"
     * @type {string}
     * @memberof ListOnly
     */
    category: string;
    /**
     * An array of product IDs, also accepts an array of altIds, e.g. [{altId:\"abcdefg\"}]
     * @type {Array<string>}
     * @memberof ListOnly
     */
    products: Array<string>;
    /**
     * Anoptional map of productIds to image URL, if supplied Flockr will return an image URL for the social proof alon with the social proof values
     * @type {{ [key: string]: string; }}
     * @memberof ListOnly
     */
    images?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    category?: Message.CategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    code?: Message.CodeEnum;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    message?: string;
    /**
     * 
     * @type {MessageRaw}
     * @memberof Message
     */
    raw?: MessageRaw;
    /**
     * an enum value or an integer representing the number of hours since last visit (for SLVA, SLVB, SLVP)
     * @type {string}
     * @memberof Message
     */
    time?: Message.TimeEnum;
}

/**
 * @export
 * @namespace Message
 */
export namespace Message {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        BASKET = <any> 'BASKET',
        LASTORDERELAPSEDTIME = <any> 'LAST_ORDER_ELAPSED_TIME',
        AUDIENCE = <any> 'AUDIENCE',
        QUANTITYORDERS = <any> 'QUANTITY_ORDERS',
        RATING = <any> 'RATING'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        TS = <any> 'TS',
        QPH = <any> 'QPH',
        LPMS = <any> 'LPMS',
        LPSP = <any> 'LPSP',
        SLVP = <any> 'SLVP',
        ATB = <any> 'ATB',
        SLVB = <any> 'SLVB',
        CAP = <any> 'CAP',
        SLVA = <any> 'SLVA',
        PRV = <any> 'PRV',
        SZ = <any> 'SZ'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TimeEnum {
        NowViewCount = <any> 'now_view_count',
        NowAtbCount = <any> 'now_atb_count',
        NowPurchaseCount = <any> 'now_purchase_count',
        NowPurchaseSampleCount = <any> 'now_purchase_sample_count',
        RecentAtbCount = <any> 'recent_atb_count',
        RecentViewCount = <any> 'recent_view_count',
        RecentPurchaseCount = <any> 'recent_purchase_count',
        RecentPurchaseSampleCount = <any> 'recent_purchase_sample_count',
        Hour1ViewCount = <any> 'hour1_view_count',
        Hour1AtbCount = <any> 'hour1_atb_count',
        Hour1PurchaseCount = <any> 'hour1_purchase_count',
        Hour1PurchaseSampleCount = <any> 'hour1_purchase_sample_count',
        Hour3ViewCount = <any> 'hour3_view_count',
        Hour3AtbCount = <any> 'hour3_atb_count',
        Hour3PurchaseCount = <any> 'hour3_purchase_count',
        Hour3PurchaseSampleCount = <any> 'hour3_purchase_sample_count',
        Hour12ViewCount = <any> 'hour12_view_count',
        Hour12AtbCount = <any> 'hour12_atb_count',
        Hour12PurchaseCount = <any> 'hour12_purchase_count',
        Hour12PurchaseSampleCount = <any> 'hour12_purchase_sample_count',
        Hour24ViewCount = <any> 'hour24_view_count',
        Hour24AtbCount = <any> 'hour24_atb_count',
        Hour24PurchaseCount = <any> 'hour24_purchase_count',
        Hour24PurchaseSampleCount = <any> 'hour24_purchase_sample_count',
        Hour48ViewCount = <any> 'hour48_view_count',
        Hour48AtbCount = <any> 'hour48_atb_count',
        Hour48PurchaseCount = <any> 'hour48_purchase_count',
        Hour48PurchaseSampleCount = <any> 'hour48_purchase_sample_count',
        Hour120ViewCount = <any> 'hour120_view_count',
        Hour120AtbCount = <any> 'hour120_atb_count',
        Hour120PurchaseCount = <any> 'hour120_purchase_count',
        Hour120PurchaseSampleCount = <any> 'hour120_purchase_sample_count',
        Hour168ViewCount = <any> 'hour168_view_count',
        Hour168AtbCount = <any> 'hour168_atb_count',
        Hour168PurchaseCount = <any> 'hour168_purchase_count',
        Hour168PurchaseSampleCount = <any> 'hour168_purchase_sample_count'
    }
}
/**
 * 
 * @export
 * @interface MessageRaw
 */
export interface MessageRaw {
    /**
     * 
     * @type {number}
     * @memberof MessageRaw
     */
    data?: number;
    /**
     * 
     * @type {MessageRawLong}
     * @memberof MessageRaw
     */
    _long?: MessageRawLong;
    /**
     * 
     * @type {MessageRawShort}
     * @memberof MessageRaw
     */
    _short?: MessageRawShort;
}
/**
 * 
 * @export
 * @interface MessageRawLong
 */
export interface MessageRawLong {
    /**
     * The long heading, these values can be managed in template for the message the Flockr portal
     * @type {string}
     * @memberof MessageRawLong
     */
    heading?: string;
    /**
     * The long text, these values can be managed in template for the message the Flockr portal
     * @type {string}
     * @memberof MessageRawLong
     */
    text?: string;
}
/**
 * 
 * @export
 * @interface MessageRawShort
 */
export interface MessageRawShort {
    /**
     * The short heading, these values can be managed in template for the message the Flockr portal
     * @type {string}
     * @memberof MessageRawShort
     */
    heading?: string;
    /**
     * The lonshortg text, these values can be managed in template for the message the Flockr portal
     * @type {string}
     * @memberof MessageRawShort
     */
    text?: string;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order extends Request {
    /**
     * The id of the order
     * @type {string}
     * @memberof Order
     */
    id: string;
    /**
     * The total value of the order including tax and shipping
     * @type {number}
     * @memberof Order
     */
    totalPrice: number;
    /**
     * The ISO code for the order currency
     * @type {string}
     * @memberof Order
     */
    currency: string;
    /**
     * 
     * @type {Array<OrderOrderItems>}
     * @memberof Order
     */
    orderItems: Array<OrderOrderItems>;
}
/**
 * 
 * @export
 * @interface OrderOrderItems
 */
export interface OrderOrderItems {
    /**
     * The product id
     * @type {string}
     * @memberof OrderOrderItems
     */
    id?: string;
    /**
     * The quantity purchased
     * @type {string}
     * @memberof OrderOrderItems
     */
    quantity: string;
    /**
     * The altId of the product (if the product ID is not available). You should use either id or altId
     * @type {string}
     * @memberof OrderOrderItems
     */
    altId?: string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product extends Request {
    /**
     * 
     * @type {ProductProduct}
     * @memberof Product
     */
    product: ProductProduct;
}
/**
 * 
 * @export
 * @interface ProductProduct
 */
export interface ProductProduct {
    /**
     * An alternative ID for the product, this is automaticall mapped to the main ID
     * @type {string}
     * @memberof ProductProduct
     */
    altId?: string;
    /**
     * The unique ID for the product - must be a string
     * @type {string}
     * @memberof ProductProduct
     */
    id: string;
    /**
     * The category of the product
     * @type {string}
     * @memberof ProductProduct
     */
    category?: string;
    /**
     * A plural name that the product is sold in, e.g. boxes
     * @type {string}
     * @memberof ProductProduct
     */
    displayPriceUnitPlural?: string;
    /**
     * A url of the product image, if supplied Flockr will respond with an image URL that can be used to display the social proof message as an image
     * @type {string}
     * @memberof ProductProduct
     */
    image?: string;
    /**
     * The name of the product
     * @type {string}
     * @memberof ProductProduct
     */
    name?: string;
    /**
     * Optional list of product IDs to fetch proof values for (can be requested on a dedicated call instead if required)
     * @type {Array<string | AltId>}
     * @memberof ProductProduct
     */
    recommendations?: Array<string | AltId>;
    /**
     * An optinal SKU for the product
     * @type {string}
     * @memberof ProductProduct
     */
    sku?: string;
    /**
     * The URL of the product
     * @type {string}
     * @memberof ProductProduct
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface Request
 */
export interface Request {
    /**
     * 
     * @type {RequestVisitor}
     * @memberof Request
     */
    visitor: RequestVisitor;
    /**
     * 
     * @type {RequestLocation}
     * @memberof Request
     */
    location: RequestLocation;
    /**
     * 
     * @type {RequestLocale}
     * @memberof Request
     */
    locale?: RequestLocale;
    /**
     * 
     * @type {RequestDevice}
     * @memberof Request
     */
    device?: RequestDevice;
}
/**
 * 
 * @export
 * @interface RequestDevice
 */
export interface RequestDevice {
    /**
     * 
     * @type {RequestDeviceScreen}
     * @memberof RequestDevice
     */
    screen?: RequestDeviceScreen;
    /**
     * 
     * @type {string}
     * @memberof RequestDevice
     */
    userAgent?: string;
}
/**
 * 
 * @export
 * @interface RequestDeviceScreen
 */
export interface RequestDeviceScreen {
    /**
     * 
     * @type {number}
     * @memberof RequestDeviceScreen
     */
    height?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestDeviceScreen
     */
    width?: number;
}
/**
 * 
 * @export
 * @interface RequestLocale
 */
export interface RequestLocale {
    /**
     * 
     * @type {string}
     * @memberof RequestLocale
     */
    language?: string;
}
/**
 * 
 * @export
 * @interface RequestLocation
 */
export interface RequestLocation {
    /**
     * The host name or ip address
     * @type {string}
     * @memberof RequestLocation
     */
    host: string;
}
/**
 * 
 * @export
 * @interface RequestVisitor
 */
export interface RequestVisitor {
    /**
     * A unique id for the visitor
     * @type {string}
     * @memberof RequestVisitor
     */
    id: string;
    /**
     * A unique id for the session
     * @type {string}
     * @memberof RequestVisitor
     */
    sessionId: string;
}
/**
 * 
 * @export
 * @interface SocialProof
 */
export interface SocialProof {
    /**
     * 
     * @type {Array<Message>}
     * @memberof SocialProof
     */
    messages?: Array<Message>;
    /**
     * 
     * @type {string}
     * @memberof SocialProof
     */
    image?: string;
    /**
     * 
     * @type {SocialProofProduct}
     * @memberof SocialProof
     */
    product?: SocialProofProduct;
}
/**
 * 
 * @export
 * @interface SocialProofProduct
 */
export interface SocialProofProduct {
    /**
     * 
     * @type {string}
     * @memberof SocialProofProduct
     */
    id?: string;
    /**
     * 
     * @type {SocialProofProductAltId}
     * @memberof SocialProofProduct
     */
    altId?: SocialProofProductAltId;
}
/**
 * 
 * @export
 * @interface SocialProofProductAltId
 */
export interface SocialProofProductAltId {
    /**
     * 
     * @type {string}
     * @memberof SocialProofProductAltId
     */
    alternativeId?: string;
    /**
     * 
     * @type {string}
     * @memberof SocialProofProductAltId
     */
    productId?: string;
    /**
     * 
     * @type {string}
     * @memberof SocialProofProductAltId
     */
    site?: string;
}
/**
 * CartApi - fetch parameter creator
 * @export
 */
export const CartApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDrawer(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cartDrawer.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling cartDrawer.');
            }
            const localVarPath = `/{apiKey}/cartDrawer/visit`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flockrDemo !== undefined) {
                localVarQueryParameter['flockrDemo'] = flockrDemo;
            }

            if (flockrFakeData !== undefined) {
                localVarQueryParameter['flockrFakeData'] = flockrFakeData;
            }

            if (transparent !== undefined) {
                localVarQueryParameter['transparent'] = transparent;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ListOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 * @export
 */
export const CartApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDrawer(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flockr> {
            const localVarFetchArgs = CartApiFetchParamCreator(configuration).cartDrawer(body, apiKey, flockrDemo, flockrFakeData, transparent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CartApi - factory interface
 * @export
 */
export const CartApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDrawer(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
            return CartApiFp(configuration).cartDrawer(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(fetch, basePath);
        },
    };
};

/**
 * CartApi - object-oriented interface
 * @export
 * @class CartApi
 * @extends {BaseAPI}
 */
export class CartApi extends BaseAPI {
    /**
     * Returns a list of Social Proof values for the products provided 
     * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
     * @param {ListOnly} body An array of product IDs or altIds
     * @param {string} apiKey your api key
     * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
     * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
     * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartDrawer(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
        return CartApiFp(this.configuration).cartDrawer(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(this.fetch, this.basePath);
    }

}
/**
 * ConversionOrderApi - fetch parameter creator
 * @export
 */
export const ConversionOrderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By passing the details of an order, the social proof for those products are updated, a product visit is counted once per session. The social proof for that product is returned 
         * @summary saves a product order and returns social proof
         * @param {Order} body Details of the product visit
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        order(body: Order, apiKey: string, flockrDemo?: string, flockrFakeData?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling order.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling order.');
            }
            const localVarPath = `/{apiKey}/conversion/order`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flockrDemo !== undefined) {
                localVarQueryParameter['flockrDemo'] = flockrDemo;
            }

            if (flockrFakeData !== undefined) {
                localVarQueryParameter['flockrFakeData'] = flockrFakeData;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversionOrderApi - functional programming interface
 * @export
 */
export const ConversionOrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * By passing the details of an order, the social proof for those products are updated, a product visit is counted once per session. The social proof for that product is returned 
         * @summary saves a product order and returns social proof
         * @param {Order} body Details of the product visit
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        order(body: Order, apiKey: string, flockrDemo?: string, flockrFakeData?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flockr> {
            const localVarFetchArgs = ConversionOrderApiFetchParamCreator(configuration).order(body, apiKey, flockrDemo, flockrFakeData, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConversionOrderApi - factory interface
 * @export
 */
export const ConversionOrderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * By passing the details of an order, the social proof for those products are updated, a product visit is counted once per session. The social proof for that product is returned 
         * @summary saves a product order and returns social proof
         * @param {Order} body Details of the product visit
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        order(body: Order, apiKey: string, flockrDemo?: string, flockrFakeData?: string, options?: any) {
            return ConversionOrderApiFp(configuration).order(body, apiKey, flockrDemo, flockrFakeData, options)(fetch, basePath);
        },
    };
};

/**
 * ConversionOrderApi - object-oriented interface
 * @export
 * @class ConversionOrderApi
 * @extends {BaseAPI}
 */
export class ConversionOrderApi extends BaseAPI {
    /**
     * By passing the details of an order, the social proof for those products are updated, a product visit is counted once per session. The social proof for that product is returned 
     * @summary saves a product order and returns social proof
     * @param {Order} body Details of the product visit
     * @param {string} apiKey your api key
     * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
     * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionOrderApi
     */
    public order(body: Order, apiKey: string, flockrDemo?: string, flockrFakeData?: string, options?: any) {
        return ConversionOrderApiFp(this.configuration).order(body, apiKey, flockrDemo, flockrFakeData, options)(this.fetch, this.basePath);
    }

}
/**
 * CustomerEventApi - fetch parameter creator
 * @export
 */
export const CustomerEventApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By passing the details of event for a product, the social proof for that product is updated. The social proof for that product is returned 
         * @summary Registers an event for the customer
         * @param {Event} body Details of the event
         * @param {string} apiKey your api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        event(body: Event, apiKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling event.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling event.');
            }
            const localVarPath = `/{apiKey}/event`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Event" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerEventApi - functional programming interface
 * @export
 */
export const CustomerEventApiFp = function(configuration?: Configuration) {
    return {
        /**
         * By passing the details of event for a product, the social proof for that product is updated. The social proof for that product is returned 
         * @summary Registers an event for the customer
         * @param {Event} body Details of the event
         * @param {string} apiKey your api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        event(body: Event, apiKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flockr> {
            const localVarFetchArgs = CustomerEventApiFetchParamCreator(configuration).event(body, apiKey, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerEventApi - factory interface
 * @export
 */
export const CustomerEventApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * By passing the details of event for a product, the social proof for that product is updated. The social proof for that product is returned 
         * @summary Registers an event for the customer
         * @param {Event} body Details of the event
         * @param {string} apiKey your api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        event(body: Event, apiKey: string, options?: any) {
            return CustomerEventApiFp(configuration).event(body, apiKey, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerEventApi - object-oriented interface
 * @export
 * @class CustomerEventApi
 * @extends {BaseAPI}
 */
export class CustomerEventApi extends BaseAPI {
    /**
     * By passing the details of event for a product, the social proof for that product is updated. The social proof for that product is returned 
     * @summary Registers an event for the customer
     * @param {Event} body Details of the event
     * @param {string} apiKey your api key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerEventApi
     */
    public event(body: Event, apiKey: string, options?: any) {
        return CustomerEventApiFp(this.configuration).event(body, apiKey, options)(this.fetch, this.basePath);
    }

}
/**
 * ImageApi - fetch parameter creator
 * @export
 */
export const ImageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns an image containing the social proof for the product, Note use https://flockr-cdn.com as the host in production
         * @param {string} apiKey your api key
         * @param {string} image URL Encoded path to the image to add/overlay social proof messages
         * @param {string} productId the unique ID of the product, must be the same ID as used in product visit
         * @param {string} visitorId A unique id for the visitor
         * @param {string} sessionId A unique id for the session
         * @param {string} [host] The host name or ip address
         * @param {string} [location] the location of the messages in the site/app, e.g. \&quot;PLP\&quot;, \&quot;PDP\&quot;, \&quot;cart\&quot; etc.
         * @param {boolean} [transparent] If transparent is false (default), returns the input image with the social proof ovelayed, if no social proof values exist for the product a 301 redirect is returned. If transparent is true, returns a transparent image to the size of the input image with the social proof message, if no social proof values for the given product a 1x1px transparent image is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        image(apiKey: string, image: string, productId: string, visitorId: string, sessionId: string, host?: string, location?: string, transparent?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling image.');
            }
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling image.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling image.');
            }
            // verify required parameter 'visitorId' is not null or undefined
            if (visitorId === null || visitorId === undefined) {
                throw new RequiredError('visitorId','Required parameter visitorId was null or undefined when calling image.');
            }
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling image.');
            }
            const localVarPath = `/{apiKey}/image`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (visitorId !== undefined) {
                localVarQueryParameter['visitorId'] = visitorId;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['sessionId'] = sessionId;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (transparent !== undefined) {
                localVarQueryParameter['transparent'] = transparent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns an image containing the social proof for the product, Note use https://flockr-cdn.com as the host in production
         * @param {string} apiKey your api key
         * @param {string} image URL Encoded path to the image to add/overlay social proof messages
         * @param {string} productId the unique ID of the product, must be the same ID as used in product visit
         * @param {string} visitorId A unique id for the visitor
         * @param {string} sessionId A unique id for the session
         * @param {string} [host] The host name or ip address
         * @param {string} [location] the location of the messages in the site/app, e.g. \&quot;PLP\&quot;, \&quot;PDP\&quot;, \&quot;cart\&quot; etc.
         * @param {boolean} [transparent] If transparent is false (default), returns the input image with the social proof ovelayed, if no social proof values exist for the product a 301 redirect is returned. If transparent is true, returns a transparent image to the size of the input image with the social proof message, if no social proof values for the given product a 1x1px transparent image is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        image(apiKey: string, image: string, productId: string, visitorId: string, sessionId: string, host?: string, location?: string, transparent?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ImageApiFetchParamCreator(configuration).image(apiKey, image, productId, visitorId, sessionId, host, location, transparent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary returns an image containing the social proof for the product, Note use https://flockr-cdn.com as the host in production
         * @param {string} apiKey your api key
         * @param {string} image URL Encoded path to the image to add/overlay social proof messages
         * @param {string} productId the unique ID of the product, must be the same ID as used in product visit
         * @param {string} visitorId A unique id for the visitor
         * @param {string} sessionId A unique id for the session
         * @param {string} [host] The host name or ip address
         * @param {string} [location] the location of the messages in the site/app, e.g. \&quot;PLP\&quot;, \&quot;PDP\&quot;, \&quot;cart\&quot; etc.
         * @param {boolean} [transparent] If transparent is false (default), returns the input image with the social proof ovelayed, if no social proof values exist for the product a 301 redirect is returned. If transparent is true, returns a transparent image to the size of the input image with the social proof message, if no social proof values for the given product a 1x1px transparent image is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        image(apiKey: string, image: string, productId: string, visitorId: string, sessionId: string, host?: string, location?: string, transparent?: boolean, options?: any) {
            return ImageApiFp(configuration).image(apiKey, image, productId, visitorId, sessionId, host, location, transparent, options)(fetch, basePath);
        },
    };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * 
     * @summary returns an image containing the social proof for the product, Note use https://flockr-cdn.com as the host in production
     * @param {string} apiKey your api key
     * @param {string} image URL Encoded path to the image to add/overlay social proof messages
     * @param {string} productId the unique ID of the product, must be the same ID as used in product visit
     * @param {string} visitorId A unique id for the visitor
     * @param {string} sessionId A unique id for the session
     * @param {string} [host] The host name or ip address
     * @param {string} [location] the location of the messages in the site/app, e.g. \&quot;PLP\&quot;, \&quot;PDP\&quot;, \&quot;cart\&quot; etc.
     * @param {boolean} [transparent] If transparent is false (default), returns the input image with the social proof ovelayed, if no social proof values exist for the product a 301 redirect is returned. If transparent is true, returns a transparent image to the size of the input image with the social proof message, if no social proof values for the given product a 1x1px transparent image is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public image(apiKey: string, image: string, productId: string, visitorId: string, sessionId: string, host?: string, location?: string, transparent?: boolean, options?: any) {
        return ImageApiFp(this.configuration).image(apiKey, image, productId, visitorId, sessionId, host, location, transparent, options)(this.fetch, this.basePath);
    }

}
/**
 * ListApi - fetch parameter creator
 * @export
 */
export const ListApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDrawer(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cartDrawer.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling cartDrawer.');
            }
            const localVarPath = `/{apiKey}/cartDrawer/visit`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flockrDemo !== undefined) {
                localVarQueryParameter['flockrDemo'] = flockrDemo;
            }

            if (flockrFakeData !== undefined) {
                localVarQueryParameter['flockrFakeData'] = flockrFakeData;
            }

            if (transparent !== undefined) {
                localVarQueryParameter['transparent'] = transparent;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ListOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs based on sample interactions, e.g, number of samples for a given product ordered. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samplesList(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling samplesList.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling samplesList.');
            }
            const localVarPath = `/{apiKey}/samplesList/visit`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flockrDemo !== undefined) {
                localVarQueryParameter['flockrDemo'] = flockrDemo;
            }

            if (flockrFakeData !== undefined) {
                localVarQueryParameter['flockrFakeData'] = flockrFakeData;
            }

            if (transparent !== undefined) {
                localVarQueryParameter['transparent'] = transparent;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ListOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListApi - functional programming interface
 * @export
 */
export const ListApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDrawer(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flockr> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).cartDrawer(body, apiKey, flockrDemo, flockrFakeData, transparent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs based on sample interactions, e.g, number of samples for a given product ordered. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samplesList(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flockr> {
            const localVarFetchArgs = ListApiFetchParamCreator(configuration).samplesList(body, apiKey, flockrDemo, flockrFakeData, transparent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ListApi - factory interface
 * @export
 */
export const ListApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDrawer(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
            return ListApiFp(configuration).cartDrawer(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(fetch, basePath);
        },
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs based on sample interactions, e.g, number of samples for a given product ordered. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samplesList(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
            return ListApiFp(configuration).samplesList(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(fetch, basePath);
        },
    };
};

/**
 * ListApi - object-oriented interface
 * @export
 * @class ListApi
 * @extends {BaseAPI}
 */
export class ListApi extends BaseAPI {
    /**
     * Returns a list of Social Proof values for the products provided 
     * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
     * @param {ListOnly} body An array of product IDs or altIds
     * @param {string} apiKey your api key
     * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
     * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
     * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public cartDrawer(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
        return ListApiFp(this.configuration).cartDrawer(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of Social Proof values for the products provided 
     * @summary Fetches a set of proofs for the provided product IDs based on sample interactions, e.g, number of samples for a given product ordered. Flockr will decide which products to return proofs for
     * @param {ListOnly} body An array of product IDs or altIds
     * @param {string} apiKey your api key
     * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
     * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
     * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListApi
     */
    public samplesList(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
        return ListApiFp(this.configuration).samplesList(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(this.fetch, this.basePath);
    }

}
/**
 * PredictiveSearchApi - fetch parameter creator
 * @export
 */
export const PredictiveSearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {Array} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictiveSearch(body: Array, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling predictiveSearch.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling predictiveSearch.');
            }
            const localVarPath = `/{apiKey}/predictiveSearch/visit`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flockrDemo !== undefined) {
                localVarQueryParameter['flockrDemo'] = flockrDemo;
            }

            if (flockrFakeData !== undefined) {
                localVarQueryParameter['flockrFakeData'] = flockrFakeData;
            }

            if (transparent !== undefined) {
                localVarQueryParameter['transparent'] = transparent;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PredictiveSearchApi - functional programming interface
 * @export
 */
export const PredictiveSearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {Array} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictiveSearch(body: Array, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flockr> {
            const localVarFetchArgs = PredictiveSearchApiFetchParamCreator(configuration).predictiveSearch(body, apiKey, flockrDemo, flockrFakeData, transparent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PredictiveSearchApi - factory interface
 * @export
 */
export const PredictiveSearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {Array} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictiveSearch(body: Array, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
            return PredictiveSearchApiFp(configuration).predictiveSearch(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(fetch, basePath);
        },
    };
};

/**
 * PredictiveSearchApi - object-oriented interface
 * @export
 * @class PredictiveSearchApi
 * @extends {BaseAPI}
 */
export class PredictiveSearchApi extends BaseAPI {
    /**
     * Returns a list of Social Proof values for the products provided 
     * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
     * @param {Array} body An array of product IDs or altIds
     * @param {string} apiKey your api key
     * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
     * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
     * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PredictiveSearchApi
     */
    public predictiveSearch(body: Array, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
        return PredictiveSearchApiFp(this.configuration).predictiveSearch(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(this.fetch, this.basePath);
    }

}
/**
 * ProductDetailsApi - fetch parameter creator
 * @export
 */
export const ProductDetailsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By passing the details of a product visit, the social proof for that product is updagted, a product visit is counted once per session. The social proof for that product is returned 
         * @summary saves a product visit and returns social proof
         * @param {Product} body Details of the product visit
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVisit(body: Product, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling productVisit.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling productVisit.');
            }
            const localVarPath = `/{apiKey}/product/visit`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flockrDemo !== undefined) {
                localVarQueryParameter['flockrDemo'] = flockrDemo;
            }

            if (flockrFakeData !== undefined) {
                localVarQueryParameter['flockrFakeData'] = flockrFakeData;
            }

            if (transparent !== undefined) {
                localVarQueryParameter['transparent'] = transparent;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Product" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductDetailsApi - functional programming interface
 * @export
 */
export const ProductDetailsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * By passing the details of a product visit, the social proof for that product is updagted, a product visit is counted once per session. The social proof for that product is returned 
         * @summary saves a product visit and returns social proof
         * @param {Product} body Details of the product visit
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVisit(body: Product, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flockr> {
            const localVarFetchArgs = ProductDetailsApiFetchParamCreator(configuration).productVisit(body, apiKey, flockrDemo, flockrFakeData, transparent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductDetailsApi - factory interface
 * @export
 */
export const ProductDetailsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * By passing the details of a product visit, the social proof for that product is updagted, a product visit is counted once per session. The social proof for that product is returned 
         * @summary saves a product visit and returns social proof
         * @param {Product} body Details of the product visit
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVisit(body: Product, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
            return ProductDetailsApiFp(configuration).productVisit(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(fetch, basePath);
        },
    };
};

/**
 * ProductDetailsApi - object-oriented interface
 * @export
 * @class ProductDetailsApi
 * @extends {BaseAPI}
 */
export class ProductDetailsApi extends BaseAPI {
    /**
     * By passing the details of a product visit, the social proof for that product is updagted, a product visit is counted once per session. The social proof for that product is returned 
     * @summary saves a product visit and returns social proof
     * @param {Product} body Details of the product visit
     * @param {string} apiKey your api key
     * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
     * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
     * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductDetailsApi
     */
    public productVisit(body: Product, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
        return ProductDetailsApiFp(this.configuration).productVisit(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(this.fetch, this.basePath);
    }

}
/**
 * ProductListApi - fetch parameter creator
 * @export
 */
export const ProductListApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {Array} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryVisit(body: Array, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling categoryVisit.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling categoryVisit.');
            }
            const localVarPath = `/{apiKey}/category/visit`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flockrDemo !== undefined) {
                localVarQueryParameter['flockrDemo'] = flockrDemo;
            }

            if (flockrFakeData !== undefined) {
                localVarQueryParameter['flockrFakeData'] = flockrFakeData;
            }

            if (transparent !== undefined) {
                localVarQueryParameter['transparent'] = transparent;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductListApi - functional programming interface
 * @export
 */
export const ProductListApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {Array} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryVisit(body: Array, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flockr> {
            const localVarFetchArgs = ProductListApiFetchParamCreator(configuration).categoryVisit(body, apiKey, flockrDemo, flockrFakeData, transparent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductListApi - factory interface
 * @export
 */
export const ProductListApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {Array} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryVisit(body: Array, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
            return ProductListApiFp(configuration).categoryVisit(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(fetch, basePath);
        },
    };
};

/**
 * ProductListApi - object-oriented interface
 * @export
 * @class ProductListApi
 * @extends {BaseAPI}
 */
export class ProductListApi extends BaseAPI {
    /**
     * Returns a list of Social Proof values for the products provided 
     * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
     * @param {Array} body An array of product IDs or altIds
     * @param {string} apiKey your api key
     * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
     * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
     * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductListApi
     */
    public categoryVisit(body: Array, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
        return ProductListApiFp(this.configuration).categoryVisit(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(this.fetch, this.basePath);
    }

}
/**
 * ProductRecommendationsApi - fetch parameter creator
 * @export
 */
export const ProductRecommendationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productRecommendations(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling productRecommendations.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling productRecommendations.');
            }
            const localVarPath = `/{apiKey}/productRecommendations/visit`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flockrDemo !== undefined) {
                localVarQueryParameter['flockrDemo'] = flockrDemo;
            }

            if (flockrFakeData !== undefined) {
                localVarQueryParameter['flockrFakeData'] = flockrFakeData;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ListOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductRecommendationsApi - functional programming interface
 * @export
 */
export const ProductRecommendationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productRecommendations(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flockr> {
            const localVarFetchArgs = ProductRecommendationsApiFetchParamCreator(configuration).productRecommendations(body, apiKey, flockrDemo, flockrFakeData, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductRecommendationsApi - factory interface
 * @export
 */
export const ProductRecommendationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productRecommendations(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, options?: any) {
            return ProductRecommendationsApiFp(configuration).productRecommendations(body, apiKey, flockrDemo, flockrFakeData, options)(fetch, basePath);
        },
    };
};

/**
 * ProductRecommendationsApi - object-oriented interface
 * @export
 * @class ProductRecommendationsApi
 * @extends {BaseAPI}
 */
export class ProductRecommendationsApi extends BaseAPI {
    /**
     * Returns a list of Social Proof values for the products provided 
     * @summary Fetches a set of proofs for the provided product IDs. Flockr will decide which products to return proofs for
     * @param {ListOnly} body An array of product IDs or altIds
     * @param {string} apiKey your api key
     * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
     * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductRecommendationsApi
     */
    public productRecommendations(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, options?: any) {
        return ProductRecommendationsApiFp(this.configuration).productRecommendations(body, apiKey, flockrDemo, flockrFakeData, options)(this.fetch, this.basePath);
    }

}
/**
 * SamplesApi - fetch parameter creator
 * @export
 */
export const SamplesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs based on sample interactions, e.g, number of samples for a given product ordered. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samplesList(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling samplesList.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling samplesList.');
            }
            const localVarPath = `/{apiKey}/samplesList/visit`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flockrDemo !== undefined) {
                localVarQueryParameter['flockrDemo'] = flockrDemo;
            }

            if (flockrFakeData !== undefined) {
                localVarQueryParameter['flockrFakeData'] = flockrFakeData;
            }

            if (transparent !== undefined) {
                localVarQueryParameter['transparent'] = transparent;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ListOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SamplesApi - functional programming interface
 * @export
 */
export const SamplesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs based on sample interactions, e.g, number of samples for a given product ordered. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samplesList(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Flockr> {
            const localVarFetchArgs = SamplesApiFetchParamCreator(configuration).samplesList(body, apiKey, flockrDemo, flockrFakeData, transparent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SamplesApi - factory interface
 * @export
 */
export const SamplesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a list of Social Proof values for the products provided 
         * @summary Fetches a set of proofs for the provided product IDs based on sample interactions, e.g, number of samples for a given product ordered. Flockr will decide which products to return proofs for
         * @param {ListOnly} body An array of product IDs or altIds
         * @param {string} apiKey your api key
         * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
         * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
         * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samplesList(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
            return SamplesApiFp(configuration).samplesList(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(fetch, basePath);
        },
    };
};

/**
 * SamplesApi - object-oriented interface
 * @export
 * @class SamplesApi
 * @extends {BaseAPI}
 */
export class SamplesApi extends BaseAPI {
    /**
     * Returns a list of Social Proof values for the products provided 
     * @summary Fetches a set of proofs for the provided product IDs based on sample interactions, e.g, number of samples for a given product ordered. Flockr will decide which products to return proofs for
     * @param {ListOnly} body An array of product IDs or altIds
     * @param {string} apiKey your api key
     * @param {string} [flockrDemo] append this parameter with the value \&quot;true\&quot; to return demo data for testing
     * @param {string} [flockrFakeData] append this value to return demo data of a specific proof type
     * @param {boolean} [transparent] if supplied as well as an image url, will define whether a transparent based image url is returned for the image with social proof applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SamplesApi
     */
    public samplesList(body: ListOnly, apiKey: string, flockrDemo?: string, flockrFakeData?: string, transparent?: boolean, options?: any) {
        return SamplesApiFp(this.configuration).samplesList(body, apiKey, flockrDemo, flockrFakeData, transparent, options)(this.fetch, this.basePath);
    }

}
